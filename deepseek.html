<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéπ miniPiano ¬∑ instrument app</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: linear-gradient(145deg, #2b3a4a 0%, #1d2a36 100%);
            min-height: 100vh;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        }

        .piano-container {
            background: #0f1a24;
            border-radius: 2rem 2rem 1.5rem 1.5rem;
            padding: 2rem 2rem 1.5rem 2rem;
            box-shadow: 0 30px 40px rgba(0, 0, 0, 0.7), inset 0 1px 4px rgba(255, 255, 255, 0.08);
            border-bottom: 6px solid #00000055;
        }

        /* header / control panel */
        .controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #dae2ed;
            margin-bottom: 1.2rem;
            padding: 0 0.5rem;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .brand span {
            font-size: 1.6rem;
            filter: drop-shadow(0 2px 3px black);
        }

        .brand h1 {
            font-size: 1.2rem;
            font-weight: 400;
            letter-spacing: 2px;
            text-transform: uppercase;
            background: #ffffff0c;
            padding: 0.2rem 1rem;
            border-radius: 40px;
            border: 1px solid #3e566b;
            box-shadow: inset 0 1px 3px #00000055;
            margin: 0;
        }

        .keyboard-type {
            background: #25313e;
            border-radius: 30px;
            padding: 0.3rem 0.5rem;
            font-size: 0.8rem;
            font-weight: 500;
            border: 1px solid #3f5568;
            color: #b4cfec;
            box-shadow: inset 0 1px 2px #0b1015;
        }

        /* the actual piano keyboard */
        .keyboard {
            display: flex;
            position: relative;
            height: 220px;
            margin: 10px 0 5px 0;
            box-shadow: 0 8px 0 #05080b, 0 12px 25px rgba(0,0,0,0.7);
            border-radius: 0 0 12px 12px;
            overflow: hidden;
            border-left: 2px solid #2e3f4e;
            border-right: 2px solid #2e3f4e;
        }

        .white-key {
            flex: 1;
            background: linear-gradient(180deg, #f6f9fe 0%, #e0e6ef 95%);
            border-right: 2px solid #3a4a5a;
            border-bottom: 6px solid #b7c1cd;
            border-radius: 0 0 12px 12px;
            cursor: pointer;
            transition: all 0.04s ease;
            position: relative;
            z-index: 1;
            box-shadow: inset 0 -5px 8px #0000001a;
        }

        .white-key:last-child {
            border-right: none;
        }

        /* black key container ‚Äì absolute overlay */
        .black-keys {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            pointer-events: none;  /* allow clicks to pass to whites underneath */
            z-index: 10;
        }

        .black-key {
            pointer-events: auto;   /* but blacks catch their own clicks */
            background: linear-gradient(165deg, #2b3a47, #11161e);
            height: 68%;
            width: 7.2%;           /* relative to parent width, fine tuned */
            border-radius: 0 0 8px 8px;
            border-left: 2px solid #5f7487;
            border-right: 2px solid #10161e;
            border-bottom: 6px solid #030609;
            box-shadow: inset 0 -2px 5px #00000088, 0 6px 8px #00000099;
            cursor: pointer;
            transition: all 0.04s;
            margin-left: -1%;       /* fine positioning */
            transform-origin: top;
        }

        /* push black keys to their positions using dummy spacers */
        .black-key-positions {
            display: flex;
            width: 100%;
            justify-content: space-evenly;
            padding: 0 2.9%;       /* align them above white key groups */
            gap: 4.2%;
        }

        /* white key press effect */
        .white-key.active {
            background: linear-gradient(0deg, #d2deec, #b9c6d6);
            border-bottom-width: 2px;
            transform: translateY(4px);
            box-shadow: inset 0 2px 8px #00000044;
        }

        .black-key.active {
            background: #1c262f;
            border-bottom-width: 2px;
            transform: translateY(4px);
            box-shadow: inset 0 2px 5px black;
        }

        /* footer labels */
        .note-labels {
            display: flex;
            padding: 0 1% 0 1%;
            margin-top: 0.5rem;
            color: #b2c7de;
            font-weight: 500;
            font-size: 0.9rem;
            text-shadow: 0 1px 2px black;
        }

        .white-label {
            flex: 1;
            text-align: center;
            letter-spacing: 1px;
            opacity: 0.7;
            transition: opacity 0.1s;
        }

        .footer-info {
            display: flex;
            justify-content: space-between;
            margin-top: 1.5rem;
            color: #7a92ab;
            font-size: 0.8rem;
            padding: 0 0.8rem;
        }

        .footer-info kbd {
            background: #1f2d39;
            border-radius: 6px;
            padding: 0.2rem 0.7rem;
            color: #cfdef5;
            border: 1px solid #415a72;
            font-family: monospace;
        }

        .hint {
            display: flex;
            gap: 1rem;
        }
    </style>
</head>
<body>
<div class="piano-container">
    <!-- top bar -->
    <div class="controls">
        <div class="brand">
            <span>üéπ</span>
            <h1>miniPiano</h1>
        </div>
        <div class="keyboard-type">acoustic grand ¬∑ 10 keys</div>
    </div>

    <!-- piano keyboard -->
    <div class="keyboard" id="pianoKeyboard">
        <!-- white keys will be dynamically generated by js, but we can embed them with HTML and then attach behaviour -->
        <!-- We'll create whites manually for clarity, and inject black keys via JS / structure -->
    </div>

    <!-- note letters (white keys) -->
    <div class="note-labels" id="whiteLabels"></div>

    <!-- footer / keyboard hints -->
    <div class="footer-info">
        <div class="hint">
            <span>‚å®Ô∏è <kbd>Z</kbd> <kbd>X</kbd> <kbd>C</kbd> <kbd>V</kbd> <kbd>B</kbd> ‚Ä¶</span>
        </div>
        <div>üéµ click or type ¬∑ C major scale</div>
    </div>
</div>

<script>
    (function() {
        // ---------- white key definitions ----------
        const whiteNotes = ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'C2', 'D2', 'E2']; // 10 white keys
        // black key positions: index of the white key after which the black sits (for sharp)
        // standard pattern: C# (after C), D# (after D), F# (after F), G# (after G), A# (after A)
        // we have 10 whites -> 7 black keys (no black after E and B in lower, and after E2? we'll keep simple)
        const blackConfig = [
            { afterWhiteIndex: 0, note: 'C#' },   // after C
            { afterWhiteIndex: 1, note: 'D#' },   // after D
            { afterWhiteIndex: 3, note: 'F#' },   // after F
            { afterWhiteIndex: 4, note: 'G#' },   // after G
            { afterWhiteIndex: 5, note: 'A#' },   // after A
            { afterWhiteIndex: 7, note: 'C#2' },  // after C2 (second octave)
            { afterWhiteIndex: 8, note: 'D#2' }   // after D2
        ];

        // map key codes to notes (computer keyboard)
        const keyMap = {
            'KeyZ': 'C', 'KeyS': 'C#',
            'KeyX': 'D', 'KeyD': 'D#',
            'KeyC': 'E',
            'KeyV': 'F', 'KeyG': 'F#',
            'KeyB': 'G', 'KeyH': 'G#',
            'KeyN': 'A', 'KeyJ': 'A#',
            'KeyM': 'B',
            'KeyQ': 'C2', 'Key2': 'C#2',
            'KeyW': 'D2', 'Key3': 'D#2',
            'KeyE': 'E2'
        };

        // reverse map note -> key code (for display)
        const noteToKey = {
            'C': 'Z', 'C#': 'S',
            'D': 'X', 'D#': 'D',
            'E': 'C',
            'F': 'V', 'F#': 'G',
            'G': 'B', 'G#': 'H',
            'A': 'N', 'A#': 'J',
            'B': 'M',
            'C2': 'Q', 'C#2': '2',
            'D2': 'W', 'D#2': '3',
            'E2': 'E'
        };

        // ---------- build DOM ----------
        const keyboardEl = document.getElementById('pianoKeyboard');
        const labelsContainer = document.getElementById('whiteLabels');

        // create white keys
        whiteNotes.forEach((note, index) => {
            const whiteDiv = document.createElement('div');
            whiteDiv.className = 'white-key';
            whiteDiv.dataset.note = note;
            whiteDiv.dataset.index = index;
            whiteDiv.dataset.type = 'white';
            keyboardEl.appendChild(whiteDiv);

            // label
            const labelSpan = document.createElement('span');
            labelSpan.className = 'white-label';
            labelSpan.textContent = note;
            labelsContainer.appendChild(labelSpan);
        });

        // create black key overlay container
        const blackOverlay = document.createElement('div');
        blackOverlay.className = 'black-keys';
        const positionDiv = document.createElement('div');
        positionDiv.className = 'black-key-positions';
        blackOverlay.appendChild(positionDiv);
        keyboardEl.appendChild(blackOverlay);

        // insert black keys into the positionDiv, with spacers to align correctly
        // we need to replicate the pattern: after 0,1,3,4,5,7,8 (indices)
        // we'll walk through white keys and add a black key after specific indices using spacers.
        let whiteCount = 0;
        for (let i = 0; i < whiteNotes.length; i++) {
            // check if a black key should be placed after this white key
            const blackForThisIndex = blackConfig.find(b => b.afterWhiteIndex === i);
            if (blackForThisIndex) {
                // add a black key element
                const black = document.createElement('div');
                black.className = 'black-key';
                black.dataset.note = blackForThisIndex.note;
                black.dataset.type = 'black';
                positionDiv.appendChild(black);
            } else {
                // spacer to keep layout (empty div with same width as black key would occupy)
                const spacer = document.createElement('div');
                spacer.style.width = '7.2%'; // same as black key width
                spacer.style.marginLeft = '-1%'; // same negative margin for alignment
                spacer.style.pointerEvents = 'none';
                positionDiv.appendChild(spacer);
            }
        }

        // collect all key elements for event handling
        const whiteKeys = document.querySelectorAll('.white-key');
        const blackKeys = document.querySelectorAll('.black-key');
        const allKeys = [...whiteKeys, ...blackKeys];

        // ---------- audio context ----------
        let audioCtx = null;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        // play note with simple envelope
        function playNote(noteName) {
            try {
                initAudio();
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                // frequency mapping (just intonation for 10 keys, based on C4=261.63)
                const freqMap = {
                    'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63,
                    'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00,
                    'A#': 466.16, 'B': 493.88,
                    'C2': 523.25, 'C#2': 554.37, 'D2': 587.33, 'D#2': 622.25, 'E2': 659.25
                };
                const freq = freqMap[noteName];
                if (!freq) return;

                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'sawtooth'; // slightly richer
                osc.frequency.value = freq;

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.2, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 1.0);

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start(now);
                osc.stop(now + 1.2);
            } catch (e) {
                console.warn('audio error', e);
            }
        }

        // ---- visual activation/deactivation ----
        function activateKey(note) {
            const target = allKeys.find(key => key.dataset.note === note);
            if (target && !target.classList.contains('active')) {
                target.classList.add('active');
            }
        }

        function deactivateKey(note) {
            const target = allKeys.find(key => key.dataset.note === note);
            if (target) {
                target.classList.remove('active');
            }
        }

        function deactivateAll() {
            allKeys.forEach(k => k.classList.remove('active'));
        }

        // ---- handle mouse/touch ----
        function handleKeyMouseDown(e) {
            e.preventDefault(); // avoid drag / selection
            const key = e.currentTarget;
            const note = key.dataset.note;
            if (!note) return;

            playNote(note);
            key.classList.add('active');

            // remove active on mouseup / leave
            const onMouseUp = () => {
                key.classList.remove('active');
                document.removeEventListener('mouseup', onMouseUp);
                key.removeEventListener('mouseleave', onMouseLeave);
            };
            const onMouseLeave = () => {
                key.classList.remove('active');
                document.removeEventListener('mouseup', onMouseUp);
                key.removeEventListener('mouseleave', onMouseLeave);
            };
            document.addEventListener('mouseup', onMouseUp);
            key.addEventListener('mouseleave', onMouseLeave);
        }

        whiteKeys.forEach(k => k.addEventListener('mousedown', handleKeyMouseDown));
        blackKeys.forEach(k => k.addEventListener('mousedown', handleKeyMouseDown));

        // disable context menu on keys
        allKeys.forEach(k => k.addEventListener('contextmenu', e => e.preventDefault()));

        // ---- computer keyboard support ----
        window.addEventListener('keydown', (e) => {
            // avoid repeat flood
            if (e.repeat) return;

            const code = e.code;
            const note = keyMap[code];
            if (!note) return;

            e.preventDefault(); // prevent page scroll etc

            playNote(note);
            activateKey(note);
        });

        window.addEventListener('keyup', (e) => {
            const code = e.code;
            const note = keyMap[code];
            if (!note) return;
            e.preventDefault();
            deactivateKey(note);
        });

        // when focus leaves window, deactivate all (safety)
        window.addEventListener('blur', deactivateAll);

        // Also handle if keys are held and window loses focus: deactivate all on keyup? fine.

        // add small labels under black keys? not necessary but could show typing key
        // we can add data attribute to show computer key in tooltip but not needed.

        // for better UX: show key mapping on labels (extend note labels with small kbd)
        const labelSpans = document.querySelectorAll('.white-label');
        labelSpans.forEach((span, idx) => {
            const note = whiteNotes[idx];
            const keyChar = noteToKey[note] || '';
            span.innerHTML = `${note} <span style="font-size:0.7rem; opacity:0.8; background:#1f2f3c; padding:2px 6px; border-radius:10px;">${keyChar}</span>`;
        });

        // also add tiny key hint on black keys? optional, but we can create small overlays if wanted (skip for brevity)

        // fix: black key clicks should also trigger sound (already bound via handleKeyMouseDown)
        // but black keys are pointer-events: auto, good.

        // ensure audio context unlocks on first user interaction (any key)
        function unlockAudio() {
            initAudio();
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }
        document.body.addEventListener('mousedown', unlockAudio, { once: true });
        document.body.addEventListener('keydown', unlockAudio, { once: true });

        // Prettify: prevent drag on images etc
        console.log('piano ready! üéπ');
    })();
</script>
</body>
</html>